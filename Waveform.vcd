$version Generated by VerilatedVcd $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire  8 8 bus_i [7:0] $end
  $var wire  1 9 clk $end
  $var wire  1 : reset $end
  $scope module top $end
   $var wire  1 ; a_out $end
   $var wire  4 , address_ir [3:0] $end
   $var wire  8 < bus_d [7:0] $end
   $var wire  8 8 bus_i [7:0] $end
   $var wire  1 9 clk $end
   $var wire  1 & in_a $end
   $var wire  1 ; in_b $end
   $var wire  1 % ir_a $end
   $var wire  4 ( ir_i [3:0] $end
   $var wire  1 $ mar_a $end
   $var wire  1 ' out_a $end
   $var wire  1 ; out_b $end
   $var wire  1 ; out_bus $end
   $var wire  1 # pc_a $end
   $var wire  1 : reset $end
   $var wire  8 + to_a [7:0] $end
   $var wire  8 < to_b [7:0] $end
   $var wire  8 * to_ir [7:0] $end
   $var wire  4 ) to_ram [3:0] $end
   $scope module areg $end
    $var wire  8 - areg [7:0] $end
    $var wire  8 < bus_d [7:0] $end
    $var wire  1 9 clk $end
    $var wire  8 + from_ram [7:0] $end
    $var wire  1 ; out_b $end
    $var wire  1 ' ram_in $end
   $upscope $end
   $scope module control $end
    $var wire  4 ? OP_ADD [3:0] $end
    $var wire  4 B OP_DIV [3:0] $end
    $var wire  4 D OP_HLT [3:0] $end
    $var wire  4 C OP_JMP [3:0] $end
    $var wire  4 = OP_LDA [3:0] $end
    $var wire  4 > OP_LDB [3:0] $end
    $var wire  4 A OP_MUL [3:0] $end
    $var wire  4 @ OP_SUB [3:0] $end
    $var wire  1 ; aflag $end
    $var wire  8 < bus_d [7:0] $end
    $var wire  8 8 bus_i [7:0] $end
    $var wire  1 9 clk $end
    $var wire  1 & in_a $end
    $var wire  1 % ir_a $end
    $var wire  4 ( ir_i [3:0] $end
    $var wire  1 $ mar_a $end
    $var wire  1 ' out_a $end
    $var wire  1 # pc_a $end
    $var wire  1 : reset $end
    $var wire  3 . stagecount [2:0] $end
   $upscope $end
   $scope module counter $end
    $var wire  8 8 bus_i [7:0] $end
    $var wire  1 9 clk $end
    $var wire  4 / pc [3:0] $end
    $var wire  1 # pc_a $end
    $var wire  1 : reset $end
   $upscope $end
   $scope module ir $end
    $var wire  4 , address [3:0] $end
    $var wire  8 8 bus_i [7:0] $end
    $var wire  1 9 clk $end
    $var wire  8 * from_ram [7:0] $end
    $var wire  4 ( instruction [3:0] $end
    $var wire  1 % ir_a $end
    $var wire  1 : reset $end
    $var wire  4 ( to_ctrl [3:0] $end
    $var wire  4 , to_ram [3:0] $end
   $upscope $end
   $scope module mar $end
    $var wire  4 ) address [3:0] $end
    $var wire  8 8 bus_i [7:0] $end
    $var wire  1 9 clk $end
    $var wire  4 , from_ir [3:0] $end
    $var wire  1 $ mar_a $end
    $var wire  1 : reset $end
    $var wire  4 ) to_ram [3:0] $end
   $upscope $end
   $scope module ram $end
    $var wire  4 , address_ir [3:0] $end
    $var wire  1 9 clk $end
    $var wire  1 & in_a $end
    $var wire  1 ; in_b $end
    $var wire  8 5 index_ir [7:0] $end
    $var wire  8 6 index_reg [7:0] $end
    $var wire  4 ) mar_in [3:0] $end
    $var wire 129 0 mem [128:0] $end
    $var wire  1 ' out_a $end
    $var wire  1 ; out_b $end
    $var wire  8 * out_ir [7:0] $end
    $var wire  8 7 out_reg [7:0] $end
    $var wire  1 : reset $end
    $var wire  8 + to_a [7:0] $end
    $var wire  8 < to_b [7:0] $end
    $var wire  8 * to_ir [7:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
0#
0$
0%
0&
0'
b0000 (
b0000 )
b00000000 *
b00000000 +
b0000 ,
b00000000 -
b000 .
b0000 /
b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0
b00000000 5
b00000000 6
b00000000 7
b00000000 8
19
0:
0;
b00000000 <
b1000 =
b0100 >
b0010 ?
b0001 @
b1100 A
b1010 B
b1001 C
b1111 D
#1
09
#2
1#
b001 .
b0001 /
b000000000000000000000000000000000000000000000000000000000000000000000000000000000010001100100010000001111100001101000010110000100 0
b00000001 8
19
#3
09
#4
0#
1$
b0001 )
b10000100 *
b010 .
b10000100 7
b00000000 8
19
#5
09
#6
0$
1%
b1000 (
b0100 ,
b011 .
b00001000 5
19
#7
09
#8
0%
1'
b10000101 *
b10000100 +
b100 .
b00100000 6
19
#9
09
#10
0'
b00000000 +
b10000100 -
b101 .
b01000100 7
19
#11
09
#12
b00000000 -
b000 .
19
#13
09
#14
1#
b001 .
b0010 /
b00000010 8
19
#15
09
#16
0#
1$
b0010 )
b010 .
b00000000 8
19
#17
09
#18
0$
1%
b0101 ,
b011 .
b00010000 5
19
#19
09
#20
0%
1'
b10000110 *
b01000100 +
b100 .
b00101000 6
19
#21
09
#22
0'
b00000000 +
b01000100 -
b101 .
b01000110 7
19
#23
09
#24
b00000000 -
b000 .
19
#25
09
#26
1#
b001 .
b0011 /
b00000011 8
19
#27
09
#28
0#
1$
b0011 )
b010 .
b00000000 8
19
#29
09
#30
0$
1%
b0110 ,
b011 .
b00011000 5
19
#31
09
#32
0%
1'
b00001111 *
b01000110 +
b100 .
b00110000 6
19
#33
09
#34
0'
b00000000 +
b01000110 -
b101 .
b00000000 7
19
#35
09
#36
b00000000 -
b000 .
19
#37
09
#38
1#
b001 .
b0100 /
b00000100 8
19
#39
09
#40
0#
1$
b0100 )
b010 .
b00000000 8
19
#41
09
#42
0$
1%
b0000 (
b1111 ,
b011 .
b00100000 5
19
#43
09
#44
0%
b01000100 *
b100 .
b01111000 6
19
#45
09
#46
b101 .
19
#47
09
#48
b000 .
19
#49
09
#50
1#
b001 .
b0101 /
b00000101 8
19
#51
09
#52
0#
1$
b0101 )
b010 .
b00000000 8
19
#53
09
#54
0$
1%
b0100 (
b0100 ,
b011 .
b00101000 5
19
#55
09
#56
0%
b01000110 *
b100 .
b00100000 6
19
#57
09
#58
b101 .
b01000100 7
19
#59
09
#60
b000 .
19
#61
09
#62
1#
b001 .
b0110 /
b00000110 8
19
#63
09
#64
0#
1$
b0110 )
b010 .
b00000000 8
19
#65
09
#66
0$
1%
b0110 ,
b011 .
b00110000 5
19
#67
09
#68
0%
b00000000 *
b100 .
b00110000 6
19
#69
09
#70
b101 .
b00000000 7
19
#71
09
#72
b000 .
19
#73
09
#74
1#
b001 .
b0111 /
b00000111 8
19
#75
09
#76
0#
1$
b0111 )
b010 .
b00000000 8
19
#77
09
#78
0$
1%
b0000 (
b0000 ,
b011 .
b00111000 5
19
#79
09
#80
0%
b100 .
b00000000 6
19
#81
09
#82
b101 .
b10000100 7
19
#83
09
#84
b000 .
19
#85
09
#86
1#
b001 .
b1000 /
b00001000 8
19
#87
09
#88
0#
1$
b1000 )
b010 .
b00000000 8
19
#89
09
#90
0$
1%
b011 .
b01000000 5
19
#91
09
#92
0%
b100 .
19
#93
09
#94
b101 .
19
#95
09
#96
b000 .
19
#97
09
#98
1#
b001 .
b1001 /
b00001001 8
19
#99
09
